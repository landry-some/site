Юнит тесты помогают нам удостовериться, что код работает так, как мы этого хотим. Существуют библиотеки, показывающие какие строки покрыты тестами, в итоге мы имеем некоторый процент покрытия - Code Coverage.

Но насколько корректен данный показатель? Имеет ли он практический смысл и можем ли мы ему доверять? Ведь если мы удалим все `assert` строки из тестов, или просто заменим их на `assertSame(1, 1)`, то по-прежнеиу будем иметь 100% Code Coverage, при этом тесты ровным счетом не будут тестировать ничего.

На сколько уверены вы в своих тестах? Покрывают ли они все ветки ваших условий, функций? Тестируют ли они вообще хоть что-нибудь?

Ответ на этот вопрос даёт мутационное тестирование.

Мутационное тестирование - ..... (вики).

Но почему так не распрастранено? Требует ресурсы... p.2 book

Введем некоторые понятия из теории мутационного тестирования:

Очевидно, что для применения этой технологии, у нас должен быть исходный код (**source code**), некоторый набор тестов (для простоты будем говорить о модульных - **unit tests**).

После того, как у нас есть некоторые тесты, мы можем начать изменять отдельные части кода и смотреть, как реагируют на это тесты.

Одно изменение исходного кода будем называть Мутацией (**Mutation**). Например, изменение бинарного оператора `+` на бинарный `-` является мутацией кода.

Результатом мутации является Мутант (**Mutant**) - то есть это новый мутированный код.

Каждая мутация любого оператора в вашем коде (а их сотни, тысячи) приводит к новому мутанту, для которого должны быть запущены тесты.

Кроме изменение `+` на `-`, существует множество других мутационных операторов (**Mutation Operator**, **Mutator**) - отрицание условий, изменение возвращаемого значения функции, удаление строк кода и [т.д.](https://infection.github.io/guide/mutators.html)


Итак, мутационное тестирование создает множество мутантов из вашего кода, для каждого из них запускает тесты и проверяет, выполнились они успешно или нет. Если тесты упали - значит всё хорошо, они отреагировали на изменение в коде и споймали ошибку. Такой мутант считается убитым (**Killed mutant**). Если тесты выполнились успешно после мутирования - это говорит о том, что либо ваш код не покрыт в этом месте тестами вовсе, либо тесты, покрывающие мутированную строку неэффективны и в недостаточной степени тестируют данный участок кода. Такой мутант называется выжившим (**Survived, Escaped Mutant**).

Рассмотрим оба этих случая на примере.


Кроме этих двух случаев с выжившим и убитым мутантом, есть и другие. Например, изменение в цикле унарного оператора `++` у переменной счетчика на `--` может привести к тому, что цикл никогда не закончится, т.к. будет бесконечным. Задача фреймворка для мутационного тестирования корректно обрабатывать такие ситуцаии и помечать мутанта особым статусом - **Timeout**. Такой исход является положительным и мутант не считается выжившим.


описать вариант с ошибкой, таймаутом. написать что мутации должны быть умными, напримth [] - [] - бессмысленный мутант.

----------------------



! скриншоты с книги!
описать какие есть мутаторы

В последнее время все большее распространение получает мутационное тестирование.